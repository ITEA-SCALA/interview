
>>> https://javarush.ru/groups/posts/1997-algoritmih-sortirovki-v-teorii-i-na-praktike

Перемену мест часто называют — swap

Когда в нашей программе есть один цикл, время выполнения растёт линейно: чем больше элементов, тем дольше выполнение.
Получается, что алгоритм кода выше работает за линейное время (n).
n — количество элементов
В таких случаях говорят, что сложность алгоритма равна O(n).

==========================================================================================
                                                                                Алгоритмы простой сортировки

1. Сортировка пузырьком (Bubble Sort) — одна из самых простых и неэффективных сортировок.
    Сложность алгоритма равна O(n^2)
	Такая сложность называется квадратичной (так как у нас цикл в цикле).

2. Сортировка выбором (Selection Sort) — Данная сортировка неустойчива (значит что одинаковые элементы изменят свой порядок).
	Она также имеет квадратичную сложность.

3. Сортировка вставками (Insertion Sort) — Данная сортировка является устойчивой (значит что одинаковые элементы не изменят свой порядок).
    Тоже имеет квадратичную сложность.

~. Челночная сортировка (Shuttle Sort)
    Суть алгоритма в том что мы итерируемся слева направо при этом при выполнении swap элементов мы выполняем проверку всех остальных элементов которые остались позади... не нужно ли повторить swap.

~. Сортировка Шелла
    Суть её похожа на сортировку пузырьком, но каждую итерацию мы имеем разный промежуток между сравниваемыми элементами... каждую итерацию он уменьшается вдвое. 

>>  (8 базовых алгоритмических задач на собеседованиях) https://medium.com/nuances-of-programming/20-базовых-алгоритмических-задач-на-интервью-37282f6bfb14
==========================================================================================
                                                                                Алгоритмы сортировки посложнее

1. Cортировка слиянием (merge sort)
    Сложность данного алгоритма логарифмическая (нам на помощь придёт рекурсия)
	Сложность алгоритма равна O(n log n)

2. Быстрая сортировка (Quick Sort) — Данную сортировку ещё называют сортировкой Хоара (данный алгоритм в Java реализуется с помощью рекурсии).
    Она имеет алгоритмическую сложность
	Сложность алгоритма равна O(n log n)
    Суть данного алгоритма заключается в том, что в списке с элементами выбирается опорный элемент — по сути любой элемент, относительно которого нужно отсортировать остальные значения:
    - Значения меньше его — слева, значения больше — справа.

~. Сортировка подсчётом (Counting Sort) и Поразрядная сортировка (Radix Sort) — Есть с алгоритмом одна незадача: нам нужно знать минимальное и максимальное значение в массиве.
    Алгоритмическая сложность в этом случае будет O(n+k), где n — количество элементов, а k — максимальное значение элемента.





>>> (Что надо знать про коллекции в Scala) https://www.dokwork.ru/2016/05/scalacollection.html
                                                                               https://russianblogs.com/article/5282233942

>>  https://ru.stackoverflow.com/questions/1111375/scala-сортировка
изменяемые коллекции в Scala не особо частый выбор разработчика
ведь у НЕизменяемых коллекций есть ряд преимуществ, а их недостатки легко компенсируются тем как разработчики обычно пишут код.

Если надо, могу далее привести пример того как можно решить подобную задачу быстрее чем за O(n^2) на неизменяемой коллекции. 

																			   





>>> (Сортировка в Scala — пример на кошках) https://habr.com/ru/post/495130
                                                                                    https://github.com/a7emenov/scala-cats-ordering > /home/oleksandr/ScalaProjects/scala-cats-ordering
																					


>>> (Что такое хеш-таблицы, и как они работают) https://highload.today/chto-takoe-khesh-tablitsy-i-kak-oni-rabotayut
                                                                                          https://javarush.ru/groups/posts/2496-podrobnihy-razbor-klassa-hashmap
==========================================================================================
                                                                 Что такое хеш-таблицы, и как они работают

Хеширование и хеш-таблицы применяются для более удобного хранения пар ключ-значение.
Связь между значением элемента и его позицией в хеш-таблице задает хеш-функция.
Хеш-функция получает входную часть данных которую называем ключом, а на выходе она выдает целое число, которую называем хеш-значение (хеш-код).
Затем хеш-значение привязывает наш ключ к определенному индексу хеш-таблицы.


Хеш-таблица — это специальная структура данных для хранения пар ключей и их значений.
                              По сути это ассоциативный массив, в котором ключ представлен в виде хеш-функции.
главное свойство Хеш-таблиц — все операции: "вставка", "поиск" и "удаление" — в среднем выполняются за время O(1)
                                                                                                                                                     среднее время поиска по ней также равно O(1)
																																					 и в худшем случае равно O(n)

Простое представление хеш-таблиц — разместить все в алфавитном порядке и записать в некий справочник.
                                                                        В этом случае не придется искать по всей библиотеке, а только по справочнику.
                                                                        Если изначально отталкиваться от названия, то лучше использовать некий алгоритм хеширования, который обрабатывает входящее значение и выдает нужный номер

Хеш-функция должна иметь следующие свойства:
- Всегда возвращать один и тот же адрес для одного и того же ключа
- Не обязательно возвращает разные адреса для разных ключей
- Использует все адресное пространство с одинаковой вероятностью
- Быстро вычислять адрес

1. Метод цепочек — метод с открытым хешированием. 
                                     Его суть проста — элементы с одинаковым хешем попадают в одну ячейку
                                     Если ячейка с хешем уже занята, но новый ключ отличается от уже имеющегося, то новый элемент вставляется в список в виде пары ключ-значение
			    					 ставка нового элемента происходит за время O(1)
				    				 поиск элемента зависит от длины списка и в худшем случае равно O(n)

2. Открытая индексация — метод закрытого хеширования
                                                 пары ключ-значение хранятся непосредственно в хеш-таблице
												 алгоритм вставки проверяет ячейки в некотором порядке, пока не будет найдена пустая ячейка — в случае коллизии, следующие ячейки проверяются линейно, пока не будет найдена пустая ячейка
												 алгоритм поиска ищет ячейки в том же порядке, что и при вставке, пока не найдет нужный элемент или пустую ячейку, которая говорит о том, что ключ отсутствует

-----
В HashMap-е хеш-таблица реализована на основе односвязных списков (динамического массива)
Элементы массива (ячейки) еще называются корзинами (buckets), которые используются для хранения отдельно взятых узлов. Каждый из бакетов представляет из себя коллекцию

Узел представляет собой объект-класса Node (или TreeNode) вложенный во внутрь HashMap
По сути
- В TreeMap-е хеш-таблица реализована на основе списка LinkedList
- В HashMap-е хеш-таблица реализована на основе Node

мы получаем хеш-код ключа в результате работы метода "hashCode()".
Реализация по умолчанию hashCode() возвращает значение, которое называется идентификационный хеш      System.identityHashCode(Object o)
Полученный хеш-код модифицируется по формуле: хеш_код ^ (хеш_код>>> 16)

static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
-----


==========================================================================================
                                                                 Контракты equals и hashCode или как оно всё там

Метод equals() необходим в Java для подтверждения или отрицания того факта, что два объекта одного происхождения являются логически равными.
При переопределении метода equals разработчик должен придерживаться основных правил:
1. Сравнение null
    для любого заданного значения x вызов x.equals(null) должен возвращать false
2. Рефлексивность
    для любого заданного значения x, выражение x.equals(x) должно возвращать true
3. Симметричность
     для любых заданных значений x и y, x.equals(y) должно возвращать true только в том случае, когда y.equals(x) возвращает true
4. Транзитивность
     для любых заданных значений x, y и z, если x.equals(y) возвращает true и y.equals(z) возвращает true, 
	 x.equals(z) должно вернуть значение true. 
5. Согласованность
     для любых заданных значений x и y повторный вызов x.equals(y) будет возвращать значение предыдущего вызова
	 при условии, что поля, используемые для сравнения этих двух объектов, не изменялись между вызовами

Для реализации хэш-функции в спецификации языка определены следующие правила:
1. вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение
     при условии что поля объекта, участвующие в вычислении значения, не изменялись
2. вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число если эти объекты равны
3. вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения.
	(Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц)

Методы equals и hashCode необходимо переопределять вместе
Что произойдет, если будет переопределен только один из этих методов:
1. equals=есть, hashCode=нет
    — это два разных объекта, хотя они и являются логически равными. Но, т.к. они имеют разное хэш-значение мы потеряли свой объект где-то в недрах хэш-таблицы.
2. equals=нет, hashCode=есть
    — мы по-прежнему не сможем найти наш объект в хэш-таблице. Хотя будем уже близки к этому, потому что как минимум найдем корзину хэш-таблицы, в которой объект будет лежать.
3. equals=есть, hashCode=есть (всегда один) 
    — Эффективность поиска в такой HashMap-е снизиться до линейной сложности алгоритма (List)
3. hashCode=есть, equals=есть (плохой) 
    — мы будем часто получать коллизии и такая HashMap-а будет не эффективная



>>> https://habr.com/ru/post/237043
==========================================================================================
                                                                 Справочник по Java Collections Framework

На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: Collection и Map.
Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных:
1. Collection — простые последовательные наборы элементов: List, Queue, Set
                           ArrayList — это реализация интерфейса List
						                        является реализацией динамического массива объектов (его реализация основана на обычном массиве).
						                        Позволяет хранить любые данные, включая null в качестве элемента.
						                        Данную реализацию следует применять, если в процессе работы с коллекцией предплагается частое обращение к элементам по индексу.
						                        поиндексное обращение к элементам выполняется за константное время O(1).
						                        Но данную коллекцию рекомендуется избегать, если требуется частое удаление/добавление элементов в середину коллекции.
							LinkedList — это реализация интерфейса List
							                       позволяет реализовать конструкцию вида очереди FIFO (first-in-first-out) с предопределённым способом вставки и извлечения элементов
							                       Позволяет хранить любые данные, включая null (данную коллекцию можно использовать как стек или очередь)
												   Особенностью реализации данной коллекции является то, что в её основе лежит двунаправленный связный список (каждый элемент имеет ссылку на предыдущий и следующий).
												   добавление и удаление из середины, доступ по индексу, значению происходит за линейное время O(n),
												   а из начала и конца за константное O(1).
							ArrayDeque — это реализация интерфейса Deque
							                           позволяет реализовать конструкцию вида стека LIFO (last-in-first-out) с предопределённым способом вставки и извлечения элементов
													   Эта коллекция представляет собой реализацию с использованием массивов подобно ArrayList
													   но не позволяет обращаться к элементам по индексу и хранение null
													   Эта коллекция работает быстрее чем Stack, если используется как LIFO, а также быстрее чем LinkedList, если используется как FIFO.
							HashSet — реализация интерфейса Set
							                     Представляет собой неупорядоченную коллекцию
							                     Внутри использует объект HashMap для хранения данных, которая не может содержать дублирующиеся данные.
												 В качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (new Object()).
							TreeSet — реализация интерфейса Set
							                    Представляет собой коллекцию, которая не может содержать дублирующиеся данные.
												Предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator
							LinkedHashSet — реализация интерфейса Set
							                                Представляет собой коллекцию, которая не может содержать дублирующиеся данные.
							                                отличается от HashSet тем что в основе лежит LinkedHashMap, порядок элементов при обходе коллекции является идентичным порядку добавления элементов.
2. и Map — наборы пар «ключ — значение» (словари): Hashtable, HashMap, TreeMap
                     Hashtable — реализация интерфейса Map
					                        порядок хранения элементов зависит от хэш-функции.
					                        не позволяет использовать null в качестве значения или ключа.
											является синхронизированной (из-за этой особенности у неё имеются проблемы с производительностью)
											Добавление элемента выполняется за константное время O(1)
											но время удаления / получения зависит от хэш-функции. В идеале является константным, но может быть и линейным O(n).
					HashMap — реализация интерфейса Map
					                       порядок хранения элементов зависит от хэш-функции.
					                       (является альтернативой Hashtable) основными отличиями от Hashtable являются то, что HashMap не синхронизирована и использовать null как в качестве ключа, так и значения.
										   Добавление элемента выполняется за константное время O(1)
											но время удаления / получения зависит от хэш-функции. В идеале является константным, но может быть и линейным O(n).
					TreeMap — реализация интерфейса Map
										 Эта коллекция основанная на красно-чёрных деревьях.
                                         реализация Map основанная на красно-чёрных деревьях. Как и LinkedHashMap является упорядоченной. 
					                     порядок хранения элементов зависит от хэш-функции, но это поведение может быть настроено под конкретную задачу при помощи объекта Comparator
					LinkedHashMap — реализация интерфейса Map
					                                  Эта коллекция основанная на двунаправленным связям между элементами.
													  Здесь, порядок добавления элементов равен порядку итерирования элементов
													  Но это имеет недостаток — увеличение памяти которое занимет коллекция. 

Сравнение временных характеристик основных коллекций:
--- Сложность алгоритма имеет линейную зависимость
ArrayList ..... O(1) / O(n)
LinkedList ... O(n) / O(1)
--- Сложность алгоритма имеет постоянную / константную зависимость
Hashtable .............. O(1)
HashMap ............... O(1)
LinkedHashMap ... O(1)
HashSet ................. O(1)
LinkedHashSet ..... O(1)
--- Сложность алгоритма имеет логарифмическую зависимость
TreeSet ..... O(log(n))
TreeMap ... O(log(n))

>> (Luxoft | Обзор java.util.concurrent.*) https://habr.com/ru/company/luxoft/blog/157273/




>>> https://russianblogs.com/article/5282233942
                                                                 Коллекция и набор Scala

Iterable [T] - это базовая коллекция, которую можно перемещать, итеративный метод (foreach).
Seq [T] - упорядоченная коллекция.
Set [T] - это математический набор (неупорядоченный и не повторенный).
Map [T] является ассоциативным массивом, который также неупорядочен.




>>> https://javarush.ru/groups/posts/2347-klass-string-v-java
>>> https://javarush.ru/groups/posts/760-java-string-voprosih-k-sobesedovaniju-i-otvetih-na-nikh-ch2
==========================================================================================
                                          Какие различия между String, StringBuffer и StringBuilder

Класс String — является immutable — это final класс который не могут быть изменены после создания и не может иметь потомков.
                           Любые операции над объектом String приведут к созданию нового объекта.
						   Благодаря своей неизменности, объекты класса String являются потокобезопасными и могут быть использованы в многопоточной среде.
						   Каждый объект в Java, унаследованный от класса Object, может быть преобразован в строку через метод toString.

Пул строк — это набор строк, который хранится в памяти Java heap.
String это специальный класс в Java, и мы можем создавать объекты этого класса:
— используя оператор "new"
— точно так же, как и создавать объекты, предоставляя значение строки в двойных кавычках

Когда мы используем двойные кавычки для создания строки:
- сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка
- иначе создается новая строка в пуле, а затем возвращается ссылка

Когда мы используем оператор "new":
- мы принуждаем класс String создать новый объект строки
- а затем мы можем использовать метод intern() для того, чтобы поместить строку в пул, или получить из пула ссылку на другой объект-String с таким же значением

метод intern() — всегда возвращает строку которая имеет то же значение что и текущая строка, но гарантирует что это будет строка из пула уникальных строк.
метод equals() — подтверждает что пул строк уже содержит строку, эквивалентную к нашему объекту

Манипуляции со строками ресурсоемкие, поэтому Java обеспечивает два полезных класса для манипуляций со строками:
1. StringBuilder — методы StringBuilder не синхронизированы и не потокобезопасны, поэтому операции с ними работают быстрее (поскольку не обременен синронизацией).
								в однопоточном окужении мы должны использовать StringBuilder
2. StringBuffer — методы StringBuffer потокобезопасны и синхронизированы, поэтому операции с ними работают медленно.

StringBuffer и StringBuilder являются изменяемыми классами.

Пул строк также является примером паттерна Приспособленец (Flyweight).
Пул строк помогает экономить большой объем памяти, но с другой стороны создание строки занимает больше времени.

Вот почему строки преимущественно используются в качестве ключей HashMap:
- Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета.
- и они обрабатываются быстрее, чем другие объекты-ключи HashMap.




>>> http://saod.narod.ru/saod3/List013.html
>>> https://javarush.ru/groups/posts/3021-chto-sprashivajut-na-sobesedovanii-obzor-algoritmov-chastjh-1
>>> https://javarush.ru/groups/posts/3022-chto-sprashivajut-na-sobesedovanii-obzor-algoritmov-chastjh-2
>>> https://pk-region.ru/raznoe-2/mnogourovnevye-blochnye-struktury-xraneniya-dannyx-nazyvayutsya-osnovnye-struktury-dannyx-matchast-azy-xabr.html
        https://habr.com/ru/post/66926
==========================================================================================
                                             Что спрашивают на собеседовании: обзор алгоритмов

Древовидные структуры данных можно классифицировать по нескольким различным признакам:
– деревья и пирамиды
– число ветвей отходящих от корня дерева
– состояние сбалансированности дерева

Дерево — это динамическая нелинейная структура данных, каждый элемент которой содержит собственно информацию и ссылки на несколько других таких же элементов.
                 Для двоичного дерева таких ссылок две: на правый и левый элементы.

Пирамида (куча) — это древовидная структура данных в которой значения всех узлов, размещённых на одном уровне, больше или меньше значений узлов, размещённых на выше лежащем уровне 

Максимальный эффект использования двоичного дерева поиска достигается, если оно сбалансировано:
— когда все узлы, кроме терминальных, имеют непустые и правый и левый дочерних потомков
— все поддеревья, начинающиеся с одного и того же уровня, имеют одинаковую высоту

Сбалансированное бинарное дерево — это максимально широкое и низкое дерево

Вырожденное дерево (лоза) — это (обратный случай) дерево выродившееся в линейный односвязный список
                                                         такое дерево получается, если заносимые в него данные упорядочены по-возрастанию или по-убыванию
                                                         вырожденные деревья — являются частным случаем ориентированных деревьев и получили название лево-ассоциативных или право-ассоциативных лозы


Многоключевые деревья — являются сбалансированными деревьями у которых число ветвей, исходящих из узлов, может быть 2 и более
Префиксное дерево — это разновидность дерева поиска.
                                           Такие структуры часто используют чтобы хранить слова и выполнять быстрый поиск по ним...
                                           Оно хранит данные в метках, каждая из которых представляет собой узел на дереве
Двоичное (бинарное) дерево — иерархическая структура данных в которой каждый узел имеет не более двух потомков (детей)
                                                          первый называется родительским узлом, а дети называются левыми и правыми наследниками
														  является упорядоченным ориентированным деревом
Красно-чёрное дерево — в этой структуре баланс достигается за счет раскраски вершин в два цвета подчиняющейся следующим правилам:
                                               Корень дерева черный
                                               Красная вершина не может быть сыном красной вершины
											   Черная глубина любого листа одинакова
											   считается, что красно-чёрное дерево требует меньшего объёма памяти для хранения отдельного узла (чем АВЛ-дерево)
АВЛ-дерево -— "операции вращения" используемые при балансировке -— представляют переприсвоения значений указателей в узлах дерева
                            (и, как следствие, перепроведение связей между узлами, после которого высоты левой и правой ветвей оказываются одинаковыми)


— Корневой узел — это самый верхний узел дерева (узел 8 на примере).
— Корень — это одна из вершин, по желанию наблюдателя.
— Лист (листовой или терминальный узел) — это узел, не имеющий дочерних элементов
— Внутренний узел — это любой узел дерева, имеющий потомков, и таким образом, не являющийся листовым терминальным узлом


>>> (одробный обход Scala Tree Fold в глубину) https://russianblogs.com/article/42361526867
==========================================================================================
                                                                                Определение дерева

Есть два способа пройти по дереву:
1. сначала в глубину — Поиск в глубину это своего рода алгоритм на основе графа.
    Процесс заключается в кратком углублении каждого возможного пути ветвления до "точки-глубже" и к каждому узлу можно получить доступ только один раз.
	* Найдите корневой узел и левое поддерево.
	* Поиск в левом поддереве текущего дерева.
	* Поиск в левом поддереве текущего дерева.
	* Вернитесь к родительскому узлу, найдите родительский узел Правое поддерево
	* Найдите левое поддерево текущего дерева.
	* Вернитесь к родительскому узлу, найдите родительский узел Правое поддерево
	* Вернитесь к родительскому узлу, вернитесь к родительскому узлу, вернитесь к родительскому узлу, найдите правое поддерево.
2. сначала в ширину



>>> https://javarush.ru/groups/posts/496-patternih-proektirovanija-v-java
>>> https://javarush.ru/groups/posts/584-patternih-proektirovanija
>>> https://studfile.net/preview/16584796
>>> (Паттерны проектирования в Java) https://javarush.ru/groups/posts/2267-patternih-proektirovanija-v-java
                                                               https://coderoad.ru/1673841/Примеры-паттернов-проектирования-GoF-в-базовых-библиотеках-Java
															   https://refactoring.guru/uk/design-patterns/java
															   https://javarush.ru/groups/posts/1035-raznica-mezhdu-patternami-sostojanie-i-strategija-v-java
															   https://karpsy.ru/application/pattern-sostoyanie-raznica-mezhdu-patternami-sostoyanie-i-strategiya-v.html
															   https://russianblogs.com/article/50421702102 >> https://proselyte.net/tutorials/jsf-tutorial/jsf-application-life-cycle
															   https://bool.dev/blog/detail/gof-design-patterns
															   https://javascopes.com/spring-framework-design-patterns-cfe595de
															   https://studfile.net/preview/16584796/page:2
															   https://habr.com/ru/company/otus/blog/451516
															   https://russianblogs.com/article/975193439
															   https://eremeykin.github.io/2021/09/30/visitor.html
															   https://bool.dev/blog/detail/pattern-posetitel
															   http://www.javenue.info/post/design-patterns-java
>>> (Евгений Борисов — Spring Patterns для взрослых) https://www.youtube.com/watch?v=GL1txFxswHA
==========================================================================================
                                                                       Паттерны проектирования GOF

+ Порождающие шаблоны
   --------------------------------[ это паттерны которые абстрагируют процесс порождения классов и объектов ]
   1. Singleton (Одиночка) — гарантирует наличие единственного экземпляра класса.
                                            Данный паттерн интересен тем, что на нём часто показывают проблемы многопоточности.
											Его действие можно увидеть на примере класс подключения к базе данных java.sql.DriverManager.getConnection().
											В Spring ограничивает синглтон одним объектом на контейнер Spring IoC (это означает что Spring создаст только один компонент для каждого типа в контексте приложения)
   2. Builder (Строитель) — позволяет пошагово создавать сложные объекты.
                                           В Java самый известный пример — StringBuilder
   3. Prototype (Прототип) — новые объекты создаются по образу и подобию уже существующих объектов, т.е. по их прототипу.
											 В Java, его действие можно увидеть на примере интерфейса java.lang.Cloneable.
											 вызывающий не знает как устроен метод clone(), то есть создание объекта по прототипу это обязанность самого объекта.
   4. Factory method (Фабричный метод) — создаёт объект через отдельный метод.
                                                                    В Java, его действие можно увидеть на примере класса java.util.Calendar.
																	Сам класс Calendar абстрактный, а чтобы его создавать используется метод getInstance()
																	это обусловлено тем, что логика создания объекта может быть непростой, в нашем случае мы обращаемся к базовому классу Calendar, а создаётся класс GregorianCalendar.
   5. Abstract factory (Абстрактная фабрика) — описываем сущность для создания целых семейств взаимосвязанных объектов
																		  То есть в зависимости от окружения (например от операционной системы) мы получим определённую фабрику которая создаст совместимые элементы.
																		  Главное, чтобы она создавала правильные реализации (нам не важны детали реализации, т.е. не важно, какую конкретно фабрику мы получим).
																		  В Spring использует контейнер как фабрику производящую Bean-ы...

+ Структурные шаблоны
   ------------------------------[  ]
   1. Proxy (Заместитель) — предоставляет функциональность другого класса.
                                             Заместитель имеет тот же интерфейс, что и реальный объект, поэтому для клиента нет разницы работать через заместителя или напрямую.
											 (взаимодействие в паттерне идёт через интерфейсы) Прокси же может как принимать то, что нужно проксировать, так и сам управлять жизнью проксируемого объекта
											 В Java, простым примером является java.lang.reflect.Proxy: у нас есть original это HashMap, который реализует интерфейс Map.
											 В Spring использует два типа прокси:
											 1. Proxy CGLib – для проксировании классов
											 2. Динамические Proxy JDK – для проксировании интерфейсов
   2. Decorator (Декоратор) — (ещё называют обёрткой или враппером / Wrapper) на вход декоратор принимает один объект и возвращает обёртку над этим объектом.
                                               используется при динамическом проектировании объекта, можно к объекту прикрутить дополнительные свойства функциональности.
											   Прокси и декоратор очень похожи, но... декоратор оборачивается вокруг чего-то что передали на вход.
											   В Java, его действие можно увидеть в пакете ввода-вывода java io.*
											   Java IO делится на две категории:
											   1. ориентирована на байты и использует InputStream или OutputStream;
											   2. ориентирована на использование символов и использует Reader или Writer;
											   Для структуры всех этих классов используется паттерн декоратор.
   3. Adapter (Адаптер) — это конвертер между двумя несовместимыми объектами.
                                        Используя паттерн адаптера, мы можем объединить два несовместимых интерфейса.
										Он похож на декоратор, но отличие в том что цель у него не изменение функционала, а адаптация одного интерфейса к другому.
										В Java есть очень яркий пример:   List<String> strings = Arrays.asList(...);
										(На входе у нас массив, далее мы создаём адаптер приводящий массив к интерфейсу List. Работая с List-ом на самом деле мы работаем с массивом. Поэтому добавлять элементы не выйдет т.к. изначальный массив не изменить.)
   4. Facade (Фасад) — Суть его в том, чтобы за удобным и лаконичным интерфейсом спрятать сложность использования библиотек / фрэймворков, стоящих за этим API.
                                     В Java есть пример этого паттерна — EntityManager из JPA.
   5. Flyweight (Приспособленец / Легковес) — вместо создания большого количества похожих объектов, объекты используются повторно.
                                                                         Работа этого паттерна часто связана с предварительным кэшированием или с поддержанием пула объектов.
											                             Его действие можно увидеть на примере класс подключения к базе данных java.sql.DriverManager.getConnection(), HttpClient (Connection...)
   6. Composite (Компоновщик) — использует один класс для представления внутри древовидной структуры (позволяет организовать данные в иерархическую структуру).
                                                     Интересен он тем, что некоторый набор элементов использующих один интерфейс выстраиваются в некоторую древовидную иерархию. 
													 Вызывая метод в родительском элементе мы получаем вызов этого метода по всем необходимым дочерним элементам.
													 В Java есть пример этого паттерна — UI (java.awt.*)    java.awt.Container
													 Добавили в контейнер компонент, а потом попросили контейнер применить новую ориентацию компонентов. И контейнер, зная из каких компонентов он состоит, делегировал выполнение этой команды всем дочерним компонентам.
													 (Composite позволяет организовать данные в иерархическую структуру, но предполагает, что код операций будет выполняться внутри Component-классов)
   7. Bridge (Мост) — делает конкретные классы независимыми от классов реализации интерфейса.
                                 Одну из этих иерархий считают абстракцией, а другую — реализацией.
								 Благодаря тому, что все реализации будут следовать общему интерфейсу, их можно будет взаимозаменять внутри абстракции.
								 Такой паттерн часто применяют тогда, когда есть классы "управления" и несколько видов классов "платформ" (например, Windows, Linux и т.д.).
								 В Java есть пример этого паттерна — UI (java.awt.*)

+ Поведенческие шаблоны
   ---------------------------------[ они определяют поведение и взаимодействие между классами и объектами ]
   1. Strategy (Стратегия) — (алгоритм) объект может изменять свое поведение во время выполнения программы.
                                            мы можем внутри объекта хранить то каким образом мы будем выполнять действие, т.е. объект внутри хранит стратегию, которая может быть изменена в том числе во врем выполнения кода.
											важных различий между паттернами Состояние и Стратегия: изменение Стратегии выполняется Клиентом
											В Java, простым примером является java.util.Comparator  сортирует порядок элементов, но у этого поведения есть стратегия, определённая по умолчанию...
   2. State (Состояние) — объект может изменять свое поведение в зависимости от его состояния.
                                        Паттерн "состояние" говорит, если у главного объекта есть некоторое поведение зависимое от состояние этого объекта, то тогда можно описать само состояние в виде объекта и менять объект состояния (а вызовы из главного объекта делегировать состоянию)
										важных различий между паттернами Состояние и Стратегия: изменение Состояния может быть выполнено или контекстом или самим объектом-состояния
										распознать возможность использования паттерна Состояние легко, если нужно управлять состоянием и переходами между состояниями без большого количества вложенных условных операторов
										В Java, простым примером является управление жизненным циклом JavaServer Faces (пользовательских интерфейсов для веб-приложений написанный на Java)
                                        ... JSF (JavaServer Faces) — это построения пользовательских интерфейсов для веб-приложений написанный на Java. 
                                        ... Жизненный цикл JSF управляет входными параметрами запроса от клиента, UI-компонентами и синхронизирует их с отображаемой на клиентской стороне. 
   3. Command (Команда) — интерфейс команды объявляет метод для выполнения определенного действия.
                                            В Java, простым примером является все реализации java.lang.Runnable, javax.swing.Action
   4. Chain of responsibility (Цепочка обязанностей) — если что-то надо обработать, то можно собрать обработчики в цепочку.
                                                                                    Например, такой шаблон часто используется в веб-серверах — на входе сервер имеет некоторый запрос от пользователя, дальше этот запрос проходит цепочку обработчиков (фильтры, аутентификации, заголовков запроса, обработчик кэширования и т.д)
																					В Java, простым примером является java.util.Logging
   5. Iterator (Итератор) — последовательно осуществляет доступ к элементам объекта коллекции, не зная его основного представления.
                                         Итератор обходит коллекцию так, что клиенту, использующему итератор, всё равно, что за коллекция внутри, важны лишь элементы из последовательности.
                                         В Java, простым примером является java.util.Iterator
   6. Visitor (Посетитель) — используется для упрощения операций над группировками связанных объектов.
                                            Очень похож на Iterator, Composite, отличаются они концепцией...
											Посетитель же именно про то, что есть некоторая иерархия или структура объектов, которые мы посещаем. Например, мы можем использовать отдельную обработку каталогов и отдельную обработку файлов.
											В Java простым примером является java.nio.file.FileVisitor
											(Часто Visitor работает на данных организованный при помощи шаблона Composite)
											Когда использовать паттерн Посетитель:
											— определяет операцию, выполняемую на каждом элементе из некоторой структуры.
											— позволяет, не изменяя классы этих объектов, добавлять в них новые операции.
   7. Observer (Наблюдатель) — или Publish/Subscribe, позволяет одним обьектам следить и реагировать на события, происходящие в других объектах.
                                                   Cамый удобный способ это обеспечить механизмом подписки
												   В Java, простым примером является javax.servlet.http.HttpSessionBindingListener, javax.servlet.http.HttpSessionAttributeListener
												   В Spring, простым примером является WebFlux...
												   В ReactJS...
   8. Mediator (Посредник) — в сложных системах помогает убрать связь между разными объектами и делегировать все взаимодействия между объектами некоторому объекту, который и является посредником.
                                              В Java, простым примером является java.util.Timer
                                              В Spring, простым примером является Spring MVC


    Порождающие паттерны:
    --------------------------------
1. Singleton — обеспечиваем существование в системе одного экземпляра некоторого класса
2. Builder — отделяем процесс создания комплексного объекта от его представления (позволяет пошагово создавать сложные объекты)
3. Prototype — клонируем объекты на основании некоторого базового объекта
4. Factory Method — делегируем процесс создания объектов (создаёт объект через отдельный метод)
5. Abstract Factory — описываем сущность для создания целых семейств взаимосвязанных объектов

    Структурные паттерны:
	------------------------------
1. Adapter — на основании некоторого класса создаем необходимый клиенту интерфейс (это конвертер между двумя несовместимыми объектами)
2. Facade — описываем унифицированный интерфейс для облегчения работы с набором подсистем (за удобным и лаконичным интерфейсом спрятать сложность использования стоящих за этим API)
3. Composite — работаем с базовыми и составными объектами единым образом (использует один класс для представления его внутри древовидной структуры)
4. Decorator — динамически добавляем новую функциональность некоторому объекту, сохраняя его интерфейс
5. Proxy — создаем объект, который перехватывает вызовы к другому объекту
6. Bridge — разделяем абстракцию от интерфейса, позволяя им меняться независимо
7. Flyweight — эффективно работаем с огромным количеством схожих объектов

    Поведенческие паттерны:
	---------------------------------
1. Strategy - описываем набор взаимозаменяемых алгоритмов с единым интерфейсом
2. State - позволяем объекту менять свое поведение при изменении его внутреннего состояния
3. Command - описываем объект, представляющий собой некоторое действие, которое можно выполнить в необходимый момент
4. Iterator - обеспечиваем доступ к коллекциям объектов без раскрытия внутреннего устройства этих коллекций
5. Observer - создаем объект для отслеживания изменений в подсистеме и нотификации других подсистем
6. Mediator - создаем объект, которые регулирует взаимодействие между набором подсистем
7. Visitor - отделяем алгоритм от структуры, с которыми алгоритм работает
8. Chain of responsibility - пропускаем некоторый запрос через набор обработчиков событий, до тех пор пока запрос не будет обработан



==========================================================================================
                                                                                     SOLID

S — принцип единственной ответственности. Очевидно, что синглтон противоречит ему, как уже говорилось раньше.
O — принцип открытости/закрытости: объекты должны быть открыты для расширения, но закрыты для изменения. Синглтон нарушает данный принцип, так как контролирует точку доступа и возвращает только самого себя, а не расширение.
L — принцип подстановки Барбары Лисков: объекты могут быть заменены экземплярами своих подтипов без изменения использующего их кода. Это неверно в случае с синглтоном, потому что наличие нескольких разных версий объекта означает, что это уже не синглтон.
I — принцип разделения интерфейса: много специализированных интерфейсов лучше, чем один универсальный. Это единственный принцип, который синглтон нарушает не напрямую, но лишь потому, что он не позволяет использовать интерфейс.
D — принцип инверсии зависимостей: вы должны зависеть только от абстракций, а не от чего-то конкретного. Синглтон нарушает его, потому что в данном случае зависеть можно только от конкретного экземпляра синглтона.




>>> https://proselyte.net/tutorials/spring-tutorial-full-version/bean-scope
==========================================================================================
                                                                 Область видимости бинов в Spring

В Spring Framework имеются пять возможных значений свойства scope:
1. Singleton — определяет один единственный бин для каждого контейнера Spring IoC (используется по умолчанию).
2. Prototype — позволяет иметь любое количество экземпляров бина.
3. Request — создаётся один экземпляр бина на каждый HTTP запрос (касается исключительно ApplicationContext).
4. Session — создаётся один экземпляр бина на каждую HTTP сессию (касается исключительно ApplicationContext).
5. global-session — создаётся один экземпляр бина на каждую глобальную HTTP сессию (касается исключительно ApplicationContext).


>>> https://vschol.ru/TurboPascal/gl10/gl10_1.html
==========================================================================================
                                                                 Основные принципы ООП

1. Инкапсуляция
2. Наследование
3. Полиморфизм


---

* [GitHub * Personal access tokens](https://mail.google.com/mail/u/0/?tab=rm&ogbl#inbox/KtbxLwgswrfxtLZJbFzLlPHzglccGQBXXV)
