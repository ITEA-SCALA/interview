# Паттерны проектирования GOF

* `Original`: https://github.com/olazarchuk-dev/interview

### Порождающие:
1. Singleton (Одиночка) — гарантирует наличие единственного экземпляра класса в системе
   * В Java, его действие можно увидеть на примере подключения к базе данных `java.sql.DriverManager.getConnection()`
   * В Spring, ограничивает создание Singleton-Bean-а единым объектом через Spring IoC-контейнер
2. Builder (Строитель) — отделяет процесс создания сложного объекта от его представления (т.е. позволяет пошагово создавать сложные объекты)
   * В Java, простой пример — это `java.lang.StringBuilder`
3. Factory Method (Фабричный метод) — делегируем процесс создания объектов (т.е. создаёт объект через отдельный фабричный-метод)
   * В Java, его действие можно увидеть на примере — `java.util.Calendar.getInstance()`
4. Abstract Factory (Абстрактная фабрика) — описывает фабричную-сущность для создания группы-семейств взаимосвязанных объектов
   * В Spring, использует контейнер как фабрику производящую Bean-ы... — `SpringApplication`
5. Prototype (Прототип) — клонирует объекты на основании базового объекта (новые объекты создаются по образу и подобию уже существующего объекта, т.е. по его прототипу)
   * В Java, его действие можно увидеть на примере интерфейса `java.lang.Cloneable`

### Структурные:
1. Flyweight (Приспособленец / Легковес) — позволяет эффективно работать с огромным количеством схожих объектов (т.е. классы используются повторно)
   * Его действие часто связано с предварительным кэшированием, с поддержанием пула объектов
   * В Java, действие можно увидеть на примере подключения клиентских утилит `java.sql.DriverManager.getConnection()`, `HttpClient`
2. Composite (Компоновщик) — позволяет работать единым образом со составными объектами (т.е. используется один класс для представления его внутри древовидной структуры)
   * Его действие часто связано с UI
   * В Java, действие можно увидеть на примере пакета `java.awt` — `java.awt.Container`
3. Facade (Фасад) — описывает клиентcкий интерфейс для облегчения работы с набором подсистем (т.е. за удобным, и лаконичным интерфейсом спрятать сложность использования стоящих за этим API)
   * В Java, действие можно увидеть на примере — `EntityManager` из JPA
4. Adapter (Адаптер) — создаем клиентcкий интерфейс на основании дата-класса (т.е. это конвертер между двумя несовместимыми дата-объектами)
   * Его действие часто связано с конвертацией DTO-объектов в сервисном слое
   * В Java, действие можно увидеть на примере пакета `java.awt` — `java.awt.Container`
5. Proxy (Заместитель) — предоставляет функциональность другого класса (т.е. перехватывает вызовы к другому объекту)
   * Его действие часто связано интерфейсными методами реализованными в коллекциях... `Map` = `HashMap()`, `List` = `ArrayList()`
   * В Java, действие можно увидеть на примере `java.lang.reflect.Proxy`
   * В Spring, использует два типа прокси: Proxy CGLib (для проксирования классов), Динамические Proxy JDK (для проксирования интерфейсов)
6. Decorator (Декоратор) — (обвёртка или враппер / Wrapper) динамически добавляет новую функциональность объекту, но при этом сохраняет его интерфейс (т.е. на вход декоратор принимает один объект и возвращает уже обвёртку над этим объектом)
   * Его действие часто связано с дженериками (так маркируются специальные виды классов, которые участвуют в операциях со списками)
   * В Java, его действие на примере пакета ввода-вывода `Java IO`, который делится на две категории: ориентирована на байты и использует `InputStream` или `OutputStream`; ориентирована на использование символов и использует `Reader` или `Writer`;
7. Bridge (Мост) — разделяет абстрактные-классы интерфейса от классов-реализации этого интерфейса (т.е. делает их независимыми)
   * Такой паттерн часто применяют когда есть классы "управления" и несколько видов классов "платформ" (например, Windows, Linux и т.д.)
   * В Java, действие можно увидеть на примере — UI (`java.awt.*`)

### Поведенческие:
1. Command (Команда) — просто объявляет метод-команды в интерфейсе для выполнения определенного действия
   * В Java, действие можно увидеть на примере реализаций `java.lang.Runnable`, `javax.swing.Action`
2. Strategy (Стратегия) - описывает набор взаимозаменяемых алгоритмов с единым интерфейсом (т.е. объект может изменять свое поведение во время выполнения программы)
   * В Java, действие можно увидеть на примере `java.util.Comparator` (сортирует порядок элементов в списке, но у этого поведения есть стратегия определённая по умолчанию...)
3. State (Состояние) — позволяем объекту менять свое поведение при изменении его внутреннего состояния
   * важным различием между паттернами Состояние и Стратегия: изменение Стратегии выполняется только Клиентом; а изменение Состояния может быть выполнено либо в контексте либо самим объектом-состояния;
   * Его действие часто связано с управлением жизненным циклом
   * В Java, действие можно увидеть на примере — JSF (JavaServer Faces — это построения пользовательских интерфейсов для веб-приложений написанный на Java)
4. Observer (Наблюдатель) — (Publish/Subscribe) позволяет одним объектам следить и реагировать на события, происходящие в других объектах (т.е. для отслеживания изменений в системе и нотификации в другие системы)
   * Его действие часто связано с реактивными потоками
   * В Java, действие можно увидеть на примере `javax.servlet.http.HttpSessionBindingListener`, `javax.servlet.http.HttpSessionAttributeListener`
   * В Spring, действие можно увидеть на примере — WebFlux
5. Mediator (Посредник) — ослабляет связь между разными объектами (т.е. делегировать взаимодействия между разными объектами на объект-посредник)
   * В Java, действие можно увидеть на примере `java.util.Timer`
   * В Spring, действие можно увидеть на примере — Spring MVC
6. Iterator (Итератор) — обеспечиваем доступ к элементам коллекции без раскрытия внутреннего устройства этих елементов-объектов
   * В Java, действие можно увидеть на примере `java.util.Iterator`
7. Visitor (Посетитель) — позволяет упростить операции над группами связанных объектов (т.е. отделяем алгоритм от структуры, с которыми он работает. Похож на Iterator, Composite)
   * Очень похож на Iterator, Composite, отличаются они концепцией... только наоборот
   * Его действие часто связано с: определяет операцию выполняемую на каждом элементе из некоторой структуры; позволяет не изменяя классы этих объектов, добавлять в них новые операции;
   * В Java, действие можно увидеть на примере `java.nio.file.FileVisitor`
8. Chain of responsibility (Цепочка обязанностей) — позволяет собрать обработчик сложного действия в цепочку обработчиков.
   * Его действие часто связано с описанием логики для обработки действий (это может быть сделано через лямбды и стримы)
   * В Java, действие можно увидеть на примере `java.util.Logging`


Порождающие:
---
1. Singleton — гарантирует единственный экземпляр класса в системе

2. Factory Method — создаёт объект через отдельный фабричный-метод (делегируем процесс создания объектов)
3. Abstract Factory — создаёт объект через фабричную-сущность для создания группы-семейств взаимосвязанных объектов

4. Builder — разделяет создания объекта от его представления (позволяет пошагово создавать сложные объекты)
5. Прототип — клонирует объекты (новые объекты создаются по образу и подобию уже существующего)


Структурные:
---
1. Фасад — упрощает сложность использования API с помощью клиентского интерфейса
2. Адаптер — совмещает несовместимые компоненты с помощью клиентского интерфейса
3. Bridge — разделяет и делает независимыми абстракцию от реализации

4. Proxy — перехватывает и предоставляет функциональность другого класса
5. Приспособленец — использует повторно схожие элементы из коллекции (структуры, позволяет эффективно работать)

6. Компоновщик — использует один класс для представления его внутри структуры
7. Декоратор — (враппер) добавляет новую функциональность элементу из коллекции (структуры, на вход декоратор принимает один объект и возвращает обвёртку над этим объектом)


Поведенческие (поведения, состояния, события):
---
1. Команда — объявляет метод-команды интерфейса для выполнения определенного действия
2. Стратегия — изменяет свое поведение во время выполнения программы
3. Состояние — изменяет свое поведение при изменении состояния объекта

4. Итератор — перебирает элементы коллекции (структуру) без раскрытия их внутреннего устройства
5. Mediator — ослабляет связь между компонентами системы (делегировать взаимодействия через объект-посредник)
6. Посетитель — перебирает элементы коллекции (структуру) и добавляет новую функциональность (не изменяя классы этих элементов)
7. Наблюдатель — отслеживает изменение своего состояния и уведомляет об этом другие объекты системы

8. Цепочка обязанностей — разделяет сложное действие в цепочку обработчиков



###Какие (известные) алгоритмы следует знать:
* `Пузырьковая сортировка` (bubble sort)
  - проходит по каждому элементу списка в геометрической прогрессии и сравнивает + перемещает пару элементов (рядом лежащих) в порядке сортировки...
* `Сортировка выбором` (selection sort)
  - проходит по каждому элементу списка и каждый раз сортируемая область элементов уменьшается 
* `Сортировка слиянием` (merge sort)
  - список элементов разбивается на небольшие подсписки для дальнейшей сортировки с последующим слиянием всех результатов...
* `Сортировка вставками` (insertion sort)
  - сравнивает + перемещает элементы в списке в порядке сортировки...
* Быстрая сортировка (quick sort)
* Блочная сортировка (bucket sort)

---

* [GitHub * Personal access tokens](https://mail.google.com/mail/u/0/?tab=rm&ogbl#inbox/KtbxLwgswrfxtLZJbFzLlPHzglccGQBXXV)
