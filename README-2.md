# Паттерны проектирования GOF

* `Original`: https://github.com/olazarchuk-dev/interview

### Порождающие:
1. Singleton (Одиночка) — гарантирует наличие единственного экземпляра класса в системе
   * В Java, его действие можно увидеть на примере подключения к базе данных `java.sql.DriverManager.getConnection()`
   * В Spring, ограничивает создание Singleton-Bean-а единым объектом через Spring IoC-контейнер
2. Builder (Строитель) — отделяет процесс создания сложного объекта от его представления (т.е. позволяет пошагово создавать сложные объекты)
   * В Java, простой пример — это `java.lang.StringBuilder`
3. Factory Method (Фабричный метод) — делегируем процесс создания объектов (т.е. создаёт объект через отдельный фабричный-метод)
   * В Java, его действие можно увидеть на примере — `java.util.Calendar.getInstance()`
4. Abstract Factory (Абстрактная фабрика) — описывает фабричную-сущность для создания группы-семейств взаимосвязанных объектов
   * В Spring, использует контейнер как фабрику производящую Bean-ы... — `SpringApplication`
5. Prototype (Прототип) — клонирует объекты на основании базового объекта (новые объекты создаются по образу и подобию уже существующего объекта, т.е. по его прототипу)
   * В Java, его действие можно увидеть на примере интерфейса `java.lang.Cloneable`

### Структурные:
1. Flyweight (Приспособленец / Легковес) — позволяет эффективно работать с огромным количеством схожих объектов (т.е. классы используются повторно)
   * Его действие часто связано с предварительным кэшированием, с поддержанием пула объектов
   * В Java, действие можно увидеть на примере подключения клиентских утилит `java.sql.DriverManager.getConnection()`, `HttpClient`
2. Composite (Компоновщик) — позволяет работать единым образом со составными объектами (т.е. используется один класс для представления его внутри древовидной структуры)
   * Его действие часто связано с UI
   * В Java, действие можно увидеть на примере пакета `java.awt` — `java.awt.Container`
3. Facade (Фасад) — описывает клиентcкий интерфейс для облегчения работы с набором подсистем (т.е. за удобным, и лаконичным интерфейсом спрятать сложность использования стоящих за этим API)
   * В Java, действие можно увидеть на примере — `EntityManager` из JPA
4. Adapter (Адаптер) — создаем клиентcкий интерфейс на основании дата-класса (т.е. это конвертер между двумя несовместимыми дата-объектами)
   * Его действие часто связано с конвертацией DTO-объектов в сервисном слое
   * В Java, действие можно увидеть на примере пакета `java.awt` — `java.awt.Container`
5. Proxy (Заместитель) — предоставляет функциональность другого класса (т.е. перехватывает вызовы к другому объекту)
   * Его действие часто связано интерфейсными методами реализованными в коллекциях... `Map` = `HashMap()`, `List` = `ArrayList()`
   * В Java, действие можно увидеть на примере `java.lang.reflect.Proxy`
   * В Spring, использует два типа прокси: Proxy CGLib (для проксирования классов), Динамические Proxy JDK (для проксирования интерфейсов)
6. Decorator (Декоратор) — (обвёртка или враппер / Wrapper) динамически добавляет новую функциональность объекту, но при этом сохраняет его интерфейс (т.е. на вход декоратор принимает один объект и возвращает уже обвёртку над этим объектом)
   * Его действие часто связано с дженериками (так маркируются специальные виды классов, которые участвуют в операциях со списками)
   * В Java, его действие на примере пакета ввода-вывода `Java IO`, который делится на две категории: ориентирована на байты и использует `InputStream` или `OutputStream`; ориентирована на использование символов и использует `Reader` или `Writer`;
7. Bridge (Мост) — разделяет абстрактные-классы интерфейса от классов-реализации этого интерфейса (т.е. делает их независимыми)
   * Такой паттерн часто применяют когда есть классы "управления" и несколько видов классов "платформ" (например, Windows, Linux и т.д.)
   * В Java, действие можно увидеть на примере — UI (`java.awt.*`)

### Поведенческие:
1. Command (Команда) — просто объявляет метод-команды в интерфейсе для выполнения определенного действия
   * В Java, действие можно увидеть на примере реализаций `java.lang.Runnable`, `javax.swing.Action`
2. Strategy (Стратегия) - описывает набор взаимозаменяемых алгоритмов с единым интерфейсом (т.е. объект может изменять свое поведение во время выполнения программы)
   * В Java, действие можно увидеть на примере `java.util.Comparator` (сортирует порядок элементов в списке, но у этого поведения есть стратегия определённая по умолчанию...)
3. State (Состояние) — позволяем объекту менять свое поведение при изменении его внутреннего состояния
   * важным различием между паттернами Состояние и Стратегия: изменение Стратегии выполняется только Клиентом; а изменение Состояния может быть выполнено либо в контексте либо самим объектом-состояния;
   * Его действие часто связано с управлением жизненным циклом
   * В Java, действие можно увидеть на примере — JSF (JavaServer Faces — это построения пользовательских интерфейсов для веб-приложений написанный на Java)
4. Observer (Наблюдатель) — (Publish/Subscribe) позволяет одним объектам следить и реагировать на события, происходящие в других объектах (т.е. для отслеживания изменений в системе и нотификации в другие системы)
   * Его действие часто связано с реактивными потоками
   * В Java, действие можно увидеть на примере `javax.servlet.http.HttpSessionBindingListener`, `javax.servlet.http.HttpSessionAttributeListener`
   * В Spring, действие можно увидеть на примере — WebFlux
5. Mediator (Посредник) — ослабляет связь между разными объектами (т.е. делегировать взаимодействия между разными объектами на объект-посредник)
   * В Java, действие можно увидеть на примере `java.util.Timer`
   * В Spring, действие можно увидеть на примере — Spring MVC
6. Iterator (Итератор) — обеспечиваем доступ к элементам коллекции без раскрытия внутреннего устройства этих елементов-объектов
   * В Java, действие можно увидеть на примере `java.util.Iterator`
7. Visitor (Посетитель) — позволяет упростить операции над группами связанных объектов (т.е. отделяем алгоритм от структуры, с которыми он работает. Похож на Iterator, Composite)
   * Очень похож на Iterator, Composite, отличаются они концепцией... только наоборот
   * Его действие часто связано с: определяет операцию выполняемую на каждом элементе из некоторой структуры; позволяет не изменяя классы этих объектов, добавлять в них новые операции;
   * В Java, действие можно увидеть на примере `java.nio.file.FileVisitor`
8. Chain of responsibility (Цепочка обязанностей) - Chain of responsibility (Цепочка обязанностей) — позволяет собрать обработчик сложного действия в цепочку обработчиков.
   * Его действие часто связано с описанием логики для обработки действий (это может быть сделано через лямбды и стримы)
   * В Java, действие можно увидеть на примере `java.util.Logging`
