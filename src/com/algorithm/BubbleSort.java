package com.algorithm;

import java.util.Arrays;

/**
 * Самым простым, но самым худшим решением будет сортировка пузырьком
 * В худшем случае такая сортировка имеет самую плохую квадратичную сложность — O(n^2)
 *
 * @see https://robotdreams.cc/blog/244-kakie-algoritmy-sortirovki-dolzhen-znat-junior-java-developer
 * ***
 * Итак, <пузырьковая сортировка> имеет больше недостутков чем преимуществ.
 *
 * Недостатки:
 * 1. в такой сортировке <отсутствуют алгоритмы для повышения эффективности>, с целью снизить количество попыток обращения к списку.
 *      Тоесть, такой способ имеет очень низкую продуктовность <используется много процессорного времени> при возможности задействовать большие ресурсы
 * 2. такой способ сортировки похож на <слепую сортировку>, потому-что, не зависимо от входящего состояния списка, она всегда должна выполнить полный
 *      цыкл проверок по всему списку, поэтому в этом случае мы имеем <максимальное количество попыток обращения> к списку
 * 3. каждый раз, при очередном обращении к элементу списка <выполняется дорогостоящая операция создания нового временного объекта для сортируемого элемента>,
 *      а в случае с большими и сложными структурами объектов, такая операция создания нового временнного объекта является очень затратной
 * 4. и такая операция выполняется в области <Heap памяти>, поэтому каждый новый временный объект очень сильно будет забивать оперативнцю память
 *      а это значит что <GC будет все чаще срабатывать> и этим самым он будет еще <больше тормозить работу JVM-машины> в целом
 * 4. для такого способа сортировки <сложность сильно зависит от длины списка и выростает в разы>, что очень негативно сказывается для больших списков
 * 5. механизм сортировки выполняется <только в одном потоке>, что тормозит выполнения сортировки
 * 6. такая сортировка <не является потоко-безопасной>, что плохо и противоречиво в случае для параллельных вычислений
 * 7. логические алгоритмы <не являются одинаково-эффективными для разных структур> списков
 *      там где нужно рандомно перебирать порядок элементов, для двух-связанного списка это будет медленно работать
 *
 * Преимущества:
 * 1. операция сравнения/сортировки выполняется только <для рядом стоящих по списку элементов>, что очень хорошо подходит для работы с разными списками
 *      (для доступа по индексу и также для доступа по итератору - так как она не требует повторного прохода по связанномк списку)
 * 2. <простой механизм ее реализации>
 * 3. такой механизм сортировки будет хорошо работать <для маленьких списков>
 * 4. и такой механизм сортировки будет менее затратный только <для примитивных типов>
 */
/**
 * Критерии сортировки:
 * 1.1 это сам алгоритм, который повышает эффективность сортировки
 * 1.2 разбить большой сортируемый список на маленькие подсписки, что позволит уменьшить общее количество проходов по списку согласно его размеру
 *     4*4 = 16  ||  (2*2) + (2*2) = 8
 * 2.0 использовать ресурсы процессора - выполнять сортировку подсписков паралельно, в разных тредах
 * 3.0 использовать ресурсы JVM - реализовать с помощью рекурсивного вызова, чтобы временные результаты сортировки не хранить в Heap-памяти
 *
 * При выполнении операции сортировки, большую часть своего времени компьютер простаивает...
 * И уменьшить это время выполнения сортировки, можно если максимально задействовать все ресурсы компьютера.
 * (все алгоритмы сортировки призваны повысить эффективность выполнения сортировки логическими и физическими способами...)
 *
 *
 * Сортировка в Java - это Collections.sort()
 * Collection.sort() работает, вызывая базовый Arrays.sort()
 * сама сортировка использует:
 * 1. для массивов - сортировку вставкой
 * 2. и всех для остальных - Quicksort (алгоритм "разделяй и властвуй")
 */
public class BubbleSort {

    public static void main(String[] args) {
        int[] array = {7, 8, 9, 1, 2, 3, 0, 6, 5, 4};

        System.out.println(Arrays.toString(array));

        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array.length; j++) {
                /*
                 * Каждый раз для каждого элемента, мы полностью проходимся по всему массиву
                 * Проверяем что наш условный минимальный элемент является минимальным
                 * и если это не так, тогда меняем местами элементы внутри массива
                 */
                int minVal = array[i];
                if (array[j] > minVal) {
                    array[i] = array[j];
                    array[j] = minVal;
                }
            }
        }

        System.out.println(Arrays.toString(array));
    }
}
