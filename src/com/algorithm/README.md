### Разбираем 5 ключевых алгоритмы сортировки

* `Алгоритмы сортировки в Java`: https://rukovodstvo.net/posts/id_798
* `Разбираем 5 ключевых алгоритмов сортировки`: https://robotdreams.cc/blog/244-kakie-algoritmy-sortirovki-dolzhen-znat-junior-java-developer
  - `O(n)` — **линейная сложность** — означает, что каждый элемент массива нужно будет проверить 1-раз (2-раза)
  - `O(n^2)` — **квадратическая сложность** — означает, что количество проверок будет равно n^2, где n — количество элементов
  - `O(n log n)` — **логарифмическая сложность** — означает, что количество проверок будет равно логарифму количества элементов массива
* https://www.youtube.com/playlist?list=PL6jg6AGdCNaXo06LjCBmRao-qJdf38oKp
  - `Многопоточные коллекции`: https://www.youtube.com/watch?v=-yQeYo32Lt4
  - `Сервис запуска потоков`: https://www.youtube.com/watch?v=jFKrnW5ElMg&list=PL6jg6AGdCNaXo06LjCBmRao-qJdf38oKp&index=5
  - `Реализации интерфейса Map`: https://www.youtube.com/watch?v=5Iu4ZUcrJ0g

1. Сортировка пузырьком
2. Сортировка выбором
3. Сортировка вставками
4. Сортировка слиянием
5. Быстрая сортировка

Эти алгоритмы сортировок эффективно работают для структуры массивов, с доступом по индексу.

Но для структуры с двух-связанными списками такие алгоритмы не эффективны, поскольку доступ по итератору очень медленный.

### Самым простым, но самым худшим решением будет сортировка пузырьком

Недостатки:
1. в такой сортировке **отсутствуют алгоритмы для повышения эффективности**, с целью снизить количество попыток обращения к списку.
   - То есть, такой способ имеет очень низкую продуктивность **используется впустую много процессорного времени** при возможности задействовать больше ресурсов
2. такой способ сортировки похож на <слепую сортировку>, потому-что, не зависимо от входящего состояния списка, она всегда должна выполнить полный
   - цикл проверок по всему списку, поэтому в этом случае мы имеем **максимальное количество попыток обращения** к списку
3. каждый раз, при очередном обращении к элементу списка **выполняется дорогостоящая операция создания нового временного объекта для сортируемого элемента**,
   - а в случае с большими и сложными структурами объектов, такая операция создания нового временного объекта является очень затратной
4. и такая операция выполняется в области **Heap памяти**, поэтому каждый новый временный объект очень сильно будет забивать оперативную память
   - а это значит что **GC будет все чаще срабатывать** и этим самым он будет еще **больше тормозить работу JVM-машины** в целом
4. для такого способа сортировки **сложность сильно зависит от длины списка и вырастает в разы**, что очень негативно сказывается для больших списков
5. механизм сортировки выполняется **только в одном потоке**, что тормозит выполнения сортировки
6. такая сортировка **не является потоко-безопасной**, что плохо и противоречиво в случае для параллельных вычислений
7. логические алгоритмы **не являются одинаково-эффективными для разных структур** списков
   - там где нужно рандомно перебирать порядок элементов, для двух-связанного списка это будет медленно работать

Преимущества:
1. операция сравнения/сортировки выполняется только **для рядом стоящих по списку элементов**, что очень хорошо подходит для работы с разными структурами списков
   - (для доступа по индексу и также для доступа по итератору - так как она не требует повторного прохода по связанному списку)
2. **простой механизм ее реализации**
3. такой механизм сортировки будет хорошо работать **для коротких списков**
4. и такой механизм сортировки будет **менее затратный для примитивных типов**

### Критерии сортировки:

* это умный и продуманный алгоритм, который повышает эффективность сортировки
* разбивка большого сортируемого списка на маленькие подсписки, что позволит уменьшить общее количество проходов по списку согласно его размеру
    `4*4 = 16  ||  (2*2) + (2*2) = 8`
* использовать ресурсы процессора - выполнять сортировку (подсписков) паралельно, в разных тредах
* использовать ресурсы JVM - реализовать с помощью рекурсивного вызова, чтобы временные результаты сортировки не хранить в Heap-памяти

При выполнении операции сортировки, большую часть своего времени компьютер простаивает...
И уменьшить это время выполнения сортировки, можно если максимально задействовать все ресурсы компьютера.
(Все известные алгоритмы сортировки призваны повысить эффективность выполнения сортировки логическими и физическими способами...)

* ( `Операция сортировки это прежде всего математическая операция, где сравниваются два простых числа (большее и меньшее)` )
* Но как-же быть в случае со сложными структурами объектов, где скорее всего даже чисел может и не быть:
  1. в случае со String-ом, каждый String это массив char-символов, а каждый char-символ имеет свой числовой эквивалент (-256...256)
  2. **equals и hashcode** - это еще один алгоритм, который применяется для сортировки в хеш-таблицах
     - все элементы в такой хеш-таблице отсортировываются по индексу (хеш-коду)
  3. **comparableTo** - это еще один алгоритм, который применяется для сортировки в само-сортирующих структурах
     - здесь применяется обычный механизм сортировки, где необходимо указать поля по которым объекты будут сортироваться

```text
Сортировка в Java - это Collections.sort()
Collection.sort() работает, вызывая базовый Arrays.sort()
сама сортировка использует:
1. для массивов - сортировку вставкой
2. и всех для остальных - Quicksort (алгоритм "разделяй и властвуй")
```

---

### Важно понимать природу происхождения коллекции, чтобы применить правильный тип:

1. ArrayList
   - изначально массив создается с ранее пред-определенным размером
   - а при необходимости увеличить этот список, в этом случае необходимо пересоздать новый список, но уже с другим размером
   - доступ к любому элементу массива выполняется за одинаковое короткое время
2. LinkedList
   - размер такого списка легко может быть увеличен и выполняется за одинаковое короткое время
   - но доступ к любому элементу массива выполняется последовательно, это значит нужно каждый раз обходить весь список
3. TreeSet
   - это само-сортирующие структуры, здесь каждый раз при добавлении/удалении элемента нужно выполнять сортировку и пере-балансировку дерева
   - доступ к любому элементу списка выполняется за минимальное количество шагов (но достаточно быстро)
4. HashMap
   - применяется для перевода один список в другой список

```text
Например:
* ArrayList можно применять:
  - для операций поиска
    (например: в алгоритмах для выполнения сортировки, поскольку тут ожидается рандомный поиск по индексу будет быстро работать)
* LinkedList можно применять:
  - на уровне слоя-репозитория
      данные по найденным записям (рекордам) из базы данных трансформируются в список
      (для этого лучше всего использовать LinkedList, так как изначальный размер данных получаемых из базы данных неизвестен и легко может быть расширен)
  - либо конверторы для списка из Entity в DTO и наоборот
* TreeSet можно применять:
  - при получении уникального пользователей в момент авторизации
  - возможно еще используется для построения поисковых систем по совпадению по первым 2,3,4 и более символам...
* HashMap обычно применяется в системных операциях:
  - для систем кеширования
      (например Hibernate использует для своих Кеш-уровней синхронизированные Хеш-таблицы)
  - в секюрити системах
      (например Spring использует jwt-токен для сопоставления его с профилем пользователя, чтобы пройти авторизацию)
  - в http-запросах для веб-сервисов
      (например HTTP-сессии используют привязку данных клиентского запроса к уникальному идентификатору сессии)
      (например, заголовок запроса из браузера клиента использует привязку специальных данных собранных о клиенте и достать такую инфу можно по ключу)
  - загрузка конфигурационных данных в приложение из Property через файл или из памяти
  - для конвертации данных: таймзоны, валюты, выбор клиентского языка, локализации по координатам
      (например мульти-язычный словарь переводчик)
  - (операция унмаршалинг) чтобы распарсить сложную структуру объекта со списком и добраться к нужному его элементу...
  - возможно ещё используется в stream-ах, функцией map, которая преобразует один список в другой...
```

---

### Concurrency | Способы запуска побочных потоков:

* `Callable, Future и друзья` https://javarush.ru/groups/posts/2065-threadom-java-ne-isportishjh--chastjh-iv---callable-future-i-druzjhja

1. в стандартной Java-библиотеке есть классический **Thread** ... нужно самому заботиться о правильности блокировок,
   а в Java concurrent-библиотеке есть **Callable** ... позволяет получать результаты выполнения операций.
2. **ExecutorService** ... это сервис, который использует пред-настроенный пул-потоков и управляет ими,
   а **ScheduledExecutorService** ... это тот же ExecutorService, который применяется в планировщиках заданий.
3. **ForkJoinPool фреймворк** ... этот сервис использует системные пулы-потоков, которые доступные в ресурсах.
   **CompletableFuture** ... это надстройка над ForkJoinPool, которая позволяет еще и комбинировать порядок выполнения потоков.
5. и клиентские **http-request** (ы)
    - применяются в веб-сервисах

```text
По умолчанию, в SteamAPI из Java-8 - используется ForkJoinPool фреймворк.
```
```text
Когда из побочного потока выбрасывается Exception, в этом случае главный поток об этом никогда не узнает.
Чтобы оповещать главный поток об результатах выполнения из побочных потоков - для этого есть специальный интерфейс Callable,
который возвращает тип Future (и когда в будущем побочный поток что-то выполнит, тогда Future вернет результаты его выполнения)
```

### Concurrency | Collections:

```text
Concurrency Collection - тут подразумевается не скорость работы, а прежде всего потоко-безопасность при работе со списками.
И поэтому такие коллекции работают медленнее по сравнению с обычными коллекциями.
```

```text
1. <Atomic-классы> (неблокирующий алгоритм)
2. <Synchronized Collections> синхронизированные коллекции (обвертки):
   - synchronizedCollection
   - synchronizedList
   - synchronizedMap
   - synchronizedSet
   - synchronizedSortedMap
   - synchronizedSortedSet
   Все методы, включая даже get-методы, в Synchronized collections являются синхронизированными,
     когда с коллекцией работает один поток, он локает все остальные потоки, а те, ждут, пока первый закончит работу и неразлочит их.
   Синхронизировать get-методы без надобности, так как модификаций при этом не происходит,
     но поскольку get-методы тоже синхронизированными - это будет лишний раз тормозить работу с коллекцией в многопоточной среде.
   Но итераторы, в Synchronized Collections, не являются синхронизированными.
3. <SkipList Collections> неблокирующая реализация (синхронизированный доступ без блокировок):
   - ConcurrentSkipListSet
   - ConcurrentSkipListMap
   Такие SkipList Collections реализованы на основании SkipList-ов (неблокирующих алгоритмов)
     в каждом элементе присутствует (обычный) указатель на следующий элемент, подобно LinkedList,
     и при этом в каждом элементе присутствуют еще указатели высшего уровня - перепрыгнуть на через несколько элементов,
     количество элементов для указателей высшего уровня, через которые нужно перепрыгнуть - рандомное, и Java не гарантирует конкретное число
   Здесь не нужно блокировать весь список, достаточно заблокировать только 2-элемента SkipList-а между которыми выполняется операция
     то-есть происходят только локальные мини-блокировки, поэтому такая реализация будет работать очень быстро в многопоточной среде
   Операции встака/удаление элементов происходит очень быстро
     для встаки элемента не нужно делать пере-балансировку всего списка,
     а для удаления элемента достаточно пере-привязать только указатель на следующий элемент
   Операция поиска элемента выполняется со скоростью сопоставимой как в TreeSet
     потому-что мы прыгаем по всему списку большими шагами
4. <Hashtable>
   (Это старая-добрая хеш-таблица, своего рода синхронный HashMap)
5. <CopyOnWriteArrayList>
   В таком списке синхронизированы только методы-модификации списка (get-методы здесь не синхронизированные)
6. <ConcurrentHashMap>
   В такой коллекции блокируются только отдельные бакеты, пока что-то выполняется
     (но вся коллекция при этом не блокируется)
   Операции вставки происходят очень медленно, потому-что выполняется пере-хеширование всей коллекции
     (поэтому важно сразу указывать размер коллекции в момент ее иннициализации)
   Еще очень медленно работает операция size, потому-что ему нужно несколько циклов пробежаться для получения точного размера
```

```text
Синхронизированные коллекции хорошо применять в случаях там где модифицируются списки, например:
- при сортировках, которые выполняются на стороне самого приложения в памяти (не на стороне БД)
- также это могут быть и само-сортирующие структуры (списки), которые каждый раз пере-балансируются при вставке/удалении элементов
- для работы просто с обычным списком, лучше всего применять CopyOnWriteArrayList
- там где нужны списки без дублирующих элементов, лучше применять ConcurrentSkipListSet
- там где нужно использовать хеш-карты, лучше применять Hashtable
    (Hibernate для своих кеш-уровней также использует синхронизированную хеш-карту)
- (а в случаях, где модификация списка отсутствует, лучше применять обычную коллекцию, не concurrency)
```

---

* `Процесс` - это *сам исполняющий код*, который загружается в память для дальнейшего его выполнения.
* `Поток` - это *процессорное время*, которое выделяется для выполнения этого кода.
```text
В каждом приложении существует всегда один экземпляр для исполняющий кода.
Но этот исполняющий код может выполняться в несколько потоков. 
```

* `Статические классы` - создаются только один раз, внутри приложения и живут там постоянно.
* `Динамические классы` - пересоздаются каждый раз, когда приложение их запрашивает.
```text
Так вот, каждый отдельный поток порождает новые динамические классы.
```

Параллельная обработка данных в нескольких потоках будет выполняться быстрее, чем в одном потоке.
Поток - это прежде всего процессорный ресурс, для создания которого необходимо потратить время.
Так вот, чтобы не тратить время на создание пула-потоков - существуют **wait/notify** для управления потоками.

Еще есть конкурентные данные, когда другие потоки будут ожидать пока освободиться ресурс.
А оператор **synchronized**, служит для управления доступом к конкурентным данные между потоками

1. Если *внутри одного сервиса выполняется много под-задач*:
   - в этом случае нужно применять внутренние потоки (порождать программный пул-потоков), чтобы комбинировать под-задачи внутри сервиса (`Thread`,`ExecutorService`,`ForkJoinPool`)
     ```text
     А еще wait/notify применяется, чтобы синхронизировать эти внутренние потоки для доступа к конкурентным данным, которые помечены оператором synchronized.
     ```
2. Но если *сам сервис является конкурентным объектом* данных:
   - в этом случае нужно применять synchronized, для управлять внешними потоками (`http-request`) 
     ```text
     Внешними потоками (http-request) приложение не может управлять, потому-что их порождает сам клиент.
     Но приложение может синхронизировать такие внешними потоками с помощью либо оператора synchronized либо concurrency коллекций.
     ```
   - хорошей практикой является использование static-классов
     ```text
     Потому-что данные здесь общие и также отсутствует кеширование между потоками...
     ```

Например:
```text
В главном потоке нужно создать (общий) 'Look-объект', через который потом можно будет управлять побочными потоками, с помощью wait/notify.
Обычно такой 'Look-объект' создается внутри сервиса, а сам сервис является 'Singleton-ом' (статическим).
А сами конкурентные данные, нужно завернуть в 'synchronized-блок' и передать ему этот 'Look-объект'.
```
```text
В Spring-фреймворке, по умолчанию, все сервисы уже являются Singleton-ами (статическими).
А каждый клиентский http-request, в Controller-е, порождает новый (внешний) поток, поэтому управлять внешними клиентскими потоками тут не получиться...
```

### Что такое For-цикл и Foreach в Java?

* `For loop или Foreach — что из них быстрее в Java?` https://javarush.ru/groups/posts/3843-kofe-breyk-137-for-loop-ili-foreach--chto-iz-nikh-bihstree-v-java-8-ehffektivnihkh-sposobov-per
* `Чем iterator отличается от цикла for в Java?` https://ru.stackoverflow.com/questions/765959/Чем-iterator-отличается-от-цикла-for-в-java
* `Использование Spliterator в Java` https://coderlessons.com/articles/java/ispolzovanie-spliterator-v-java

* For-циклы обычно применяются для индексируемых списков
Например:
```java
for (int i = 0; i < arrayList.length; i++) {
 /* ... */
}
```
Производительность цикла "*for*" лучше для **ArrayList**.

* Foreach в Java - это способ перебрать все элементы через Итератор, только в локаничной форме записи.
Например:
```java
Iterator<String> linkedListIterator = linkedList.iterator();
while (linkedListIterator.hasNext()) {
    String value = linkedListIterator.next();
    /* ... */
}
```
Или в локаничной форме, это тоже самое:
```java
for (String value : linkedList) {
    /* ... */
}
```
А производительность цикла "*forEach*" лучше для **LinkedList**.

```text
Если в процессе прохождения списка в цикле, этот список был модифицирован - тогда это приведет к ошибке и выбросится исключение.

Итератор - это thred-fail цикл, он ходит по копии списка и если этот список в это время был модифицирован - тогда Итератор тоже выбросит исключение.

Но если через remove-метод Итератора модифицировать список - тогда изменения будут успешно выполнены.

В каждом потоке живет новая копия объекта (списка), и каждая копия Итератора хранит свое состояние.

Бывают еще специальные Итераторы для много-поточности, которые называются - Spliterator.
```
