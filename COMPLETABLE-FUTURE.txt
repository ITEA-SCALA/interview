


Java-1: Runnable/Thread
Java-5: Callable/Future (get/isDone) /ExecutorService (Executors... submit|shutdown)
        Look-интерфейс - Semaphore/ReentrantLock/ReadWriteLock/StampedLock (оптимистическая блокировка)
        AtomicInteger, AtomicBoolean, AtomicLong, AtomicReference
Java-7: ForkJoinPool (.commonPool)/ForkJoinTask (fork - кладет/возвращает задачу в/из очередь|join - блокирует очередь до завершения задачи|compute - делит большую задачу на мелкие)
Java-8: (Future - прокси../Promise - абстрактный контейнер..) 
        CompletableFuture (вешает асинхронные кол-бэк методы + комбинирует порядок для множественных асинхронных вычислений для достижения максимальной производительности):
        -----------------
supplyAsync - соаздет новый асинхронный поток (In- Out+)
  -----...Async (такие методы выполняются в любом пуле потоков) инначе в том пуле где завершает Future
  .. thenAccept - вешает сколько угодно кол-бэк методов  (In- Out+)

  1. thenApply    (трансформация) - вешает сколько угодно кол-бэк методов                           (In+ Out+)
  2. thenCompose     (композиция) - это сценарий последовательных действий для кол-бэк методов      (In+ Out+) 
  3. thenCombine (комбинирование) - выполняется при условии что 2-а раних действия будут завершены  (In+ Out+)

  .. anyOf         - (winner) нахождение первого освободившегося потока чтобы передать ему задачу  (In- Out-)
  .. applyToEither - (winner) нахождение первого освободившегося потока чтобы передать ему задачу  (In+ Out+)
  -----
get - иннициирует всю работу


>> https://easyjava.ru/java/java-8-stream-api-chast-shestaya-sobstvennyj-potok-na-samom-dele-net >> https://github.com/EasyJavaRu/java-streams-spliterator

Интерфейс Spliterator похож на Iterator, но обладает двумя важными отличиями — можно обработать оставшееся элементы одними, а можно разделить один Spliterator на 2-а Spliterator
(Spliterator означает - разделяемый Iterator...)
(Spliterator определяет 8-методов, для 4-ёх из которых уже есть реализации по умолчанию...)
-----------
- tryAdvance() ... похож на next() обычного Iterator
- trySplit()   ... это самая мякоть Spliterator
- estimateSize() старого Spliterator после trySplit() должен возвращать оставшееся число элементов после их разделения.
- Если Spliterator не удаётся разделить или не хочется разделять или вообще что-то пошло не так, trySplit()  может вернуть null
===========
* старый Spliterator и новорождённый Spliterator никогда не должны вдвоём обработать один и тот-же элемент.

Spliterator <<< MultilineSpliterator()
Другое дополнение к классу Arrays, которое использует параллельность и лямбды - это Spliterator...




С помощью CompletableFuture и Spliterator можно имплементировать трейд-движок...
+++++++++++
Основой трейд-движка является сортировка списков и добавление изъятие элементов списка (согласно правил)
Многопоточность Java-8 позволяет и разбивать списки и разбивать действия на потоки - что увеличивает общуюю производительность
Каждое новое предложение является инициатором для выполнения пере-вычисления над всем списком (но в момент простоя никаких действий не выполняется...)

Перед выполнением действий весь набор данных должен вычитаться в трейд-движок
А по окончанию работы трейд-движка должен возвращаться результат только над выполненными элементами
После этого хранилище данных должно обновиться
(в этом случае kafka можно использовать как умное хранилище данных - новые данные будут попадать в очередь а доставленные данные будут изъяты из очереди,
 а в случае нового подписчика (например новый инстанс приложения после сбоя) тогда будут доставлены все данные + те что раньше были отправлены,
 можно так настроить kafka, чтобы удалять из очереди уже неактуальные данные и каждый раз для нового инстанса приложения возвращать все данные кроме уже удаленных...)

